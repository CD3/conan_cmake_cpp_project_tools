import typer
import pathlib
import tempfile
import fnmatch
import yaml
from rich import print
import conan_cmake_cpp_project_tools.config as config
import conan_cmake_cpp_project_tools.utils as utils
import conan_cmake_cpp_project_tools.steps as steps


APP_NAME="ccc"
app = typer.Typer(name=APP_NAME)
cfg = config.fspathtree()
progress = config.fspathtree()


@app.callback()
def main(config_file:pathlib.Path=typer.Option(None,help='ccc project config file to use.')
        ,build_type:str=typer.Option("Debug",help='The build type to compile/test.')
        ,release:bool=typer.Option(None,"--release/--debug","-R/-D",help='Set build type to "Release" or "Debug"')
        ,build_dir:pathlib.Path=typer.Option(None,help='The build directory to compile/test in. Auto-generated by default.')
        ,conanfile:pathlib.Path=typer.Option(None,help='The conanfile (conanfile.txt|conanfile.py) to install dependencies with. Detected by default.')
        ,cmakefile:pathlib.Path=typer.Option(None,help='The CMakeLists.txt file to use.')
        ,write_scripts:bool=typer.Option(False,"--write-scripts","-w",help='Write shell scripts to perform each build/test phase.')
        ):

    if release:
        build_type = "Release"
    if release is not None and not release:
        build_type = "Debug"

    config.set_defaults(cfg)
    root_dir = utils.find_project_root(pathlib.Path())
    if root_dir is None:
        print(f"[red]Could not determine root project directory for '{pathlib.Path()}'[/red]")
        raise typer.Exit(code=1)
    config.load_config_files(cfg,utils.find_project_root(pathlib.Path()).absolute(),"ccc")

    cfg['/build_type'] = build_type
    cfg['/directories/root'] = utils.find_project_root(pathlib.Path()).absolute()

    config.set_default_build_dir(cfg)
    config.set_default_conanfile(cfg)
    config.set_default_cmakefile(cfg)

    if build_dir is not None:
        cfg['directories/build'] = build_dir.absolute()
    if conanfile is not None:
        cfg['files/conanfile'] = conanfile.absolute()
    if cmakefile is not None:
        cfg['files/CMakeLists.txt'] = conanfile.absolute()

    if write_scripts:
        cfg['directories/scripts'] = cfg['directories/build']

    if cfg.get('/files/progress',None) is None:
        cfg['/files/progress'] = cfg['directories/build'] / 'ccc-progress.yml'

    if not cfg['/files/progress'].exists():
        cfg['/files/progress'].parent.mkdir(parents=True,exist_ok=True)
        cfg['/files/progress'].write_text('{}')

    progress.tree.update( yaml.safe_load( cfg['/files/progress'].read_text() ) )


    
def run_step_if_pending(name,error_msg,force_run=False):
    if force_run == False and progress.get(f'/steps/{name}', "incomplete") == "complete":
        print(f'"{name}" has step already completed. Skipping.')
        return 0
    if getattr(steps,name)(cfg) != 0:
        print(f"{error_msg}")
        progress[f'/steps/{name}'] = "error"
    else:
        progress[f'/steps/{name}'] = "complete"
    

@app.command()
def install_deps():
    '''
    Install project dependencies into build directory with Conan.
    '''

    with tempfile.TemporaryDirectory() as tmpdir:
        if not cfg.get('/directories/scripts',False):
            cfg['/directories/scripts'] = pathlib.Path(tmpdir).absolute()
        with utils.working_directory(tmpdir):
            run_step_if_pending('install_deps',"[red]There was an error installing dependencies.[/red]")

    cfg['/files/progress'].write_text( yaml.dump(progress.tree) )


@app.command()
def configure():
    '''
    Configure project build.
    '''

    with tempfile.TemporaryDirectory() as tmpdir:
        if not cfg.get('directories/scripts',False):
            cfg['directories/scripts'] = pathlib.Path(tmpdir).absolute()
        with utils.working_directory(tmpdir):
            run_step_if_pending('install_deps',"[red]There was an error installing dependencies. Halting[/red]")
            run_step_if_pending('configure_build',"[red]There was an error configuring build.[/red]")

    cfg['/files/progress'].write_text( yaml.dump(progress.tree) )

@app.command()
def build():
    '''
    Build project build.
    '''

    with tempfile.TemporaryDirectory() as tmpdir:
        if not cfg.get('directories/scripts',False):
            cfg['directories/scripts'] = pathlib.Path(tmpdir).absolute()
        with utils.working_directory(tmpdir):
            run_step_if_pending('install_deps',"[red]There was an error installing dependencies. Halting[/red]")
            run_step_if_pending('configure_build',"[red]There was an error configuring build. Halting[/red]")
            run_step_if_pending('run_build',"[red]There was an error running build.[/red]",force_run=True)
    cfg['/files/progress'].write_text( yaml.dump(progress.tree) )


# we are not naming this function `test` because pytest will pick it up as a test to run, which it is not.
@app.command(name="test")
def run_test():
    '''
    Run project unit tests.
    '''

    with tempfile.TemporaryDirectory() as tmpdir:
        if not cfg.get('directories/scripts',False):
            cfg['directories/scripts'] = pathlib.Path(tmpdir).absolute()
        with utils.working_directory(tmpdir):
            run_step_if_pending('install_deps',"[red]There was an error installing dependencies. Halting[/red]")
            run_step_if_pending('configure_build',"[red]There was an error configuring build. Halting[/red]")
            run_step_if_pending('run_build',"[red]There was an error running build. Halting[/red]",force_run=True)
            run_step_if_pending('run_tests',"[red]There was an error running tests.[/red]",force_run=True)

    cfg['/files/progress'].write_text( yaml.dump(progress.tree) )


@app.command()
def install(install_dir:pathlib.Path):
    '''
    Install project into a directory.
    '''

    cfg['cmake/install/extra_args'] = ['--prefix',str(install_dir)]

    with tempfile.TemporaryDirectory() as tmpdir:
        if not cfg.get('directories/scripts',False):
            cfg['directories/scripts'] = pathlib.Path(tmpdir).absolute()
        with utils.working_directory(tmpdir):
            # if steps.install_deps(cfg) != 0:
            #     print("[red]There was an error installing dependencies. Halting.[/red]")
            # if steps.configure_build(cfg) != 0:
            #     print("[red]There was an error configuring build. Halting.[/red]")
            # if steps.run_build(cfg) != 0:
            #     print("[red]There was an error running build. Halting[/red]")
            if steps.install(cfg) != 0:
                print("[red]There was an error installing.[/red]")
    cfg['/files/progress'].write_text( yaml.dump(progress.tree) )

@app.command()
def list_sources():
    '''
    List the source files in a project.
    '''
    include_patterns = cfg.get('/list_sources/patterns/include',['*'])
    exclude_patterns = cfg.get('/list_sources/patterns/exclude',[])
    

    for file in utils.get_source_files(cfg['/directories/root'], lambda p : utils.make_file_matches_pattern_filter(*include_patterns) and not utils.make_file_matches_pattern_filter(*exclude_patterns)):
        print(str(file))

